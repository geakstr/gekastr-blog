<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width"/>
    <title>Блог ⋅ Дмитрий Харитонов</title>
    <link rel="stylesheet" href="/theme/css/reset.css" />
    <link rel="stylesheet" href="/theme/css/common.css" />
    <link rel="stylesheet" href="/theme/css/pygment.css" />
    <link rel="stylesheet" href="/theme/css/style.css" />
<link href="/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Дмитрий Харитонов Atom Feed" /><link href="/feeds/rss.xml" type="application/rss+xml" rel="alternate" title="Дмитрий Харитонов RSS Feed" /></head>
<body>
<!-- Yandex.Metrika counter -->
<script>
(function(d, w, c) {
  (w[c] = w[c] || []).push(function() {
    try {
      w.yaCounter29914984 = new Ya.Metrika({
        id: 29914984,
        webvisor: true,
        clickmap: true,
        trackLinks: true,
        accurateTrackBounce: true,
        trackHash: true
      });
    } catch (e) {}
  });
  var n = d.getElementsByTagName("script")[0],
    s = d.createElement("script"),
    f = function() {
      n.parentNode.insertBefore(s, n);
    };
  s.type = "text/javascript";
  s.async = true;
  s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js";
  if (w.opera == "[object Opera]") {
    d.addEventListener("DOMContentLoaded", f, false);
  } else {
    f();
  }
})(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="//mc.yandex.ru/watch/29914984" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->
<header id="header">
    <nav id="menu"><ul>
      <li><h1><a id="logo" href="/">Дмитрий Харитонов</a></h1></li>
      <li><span class="muted">⋅</span></li>
      <li><em>Блог</em>
</li>
    </ul></nav>
</header>

<section id="content">
<h3 class="title"><em>О разработке и всём таком</em></h3>

<article class="post">
    <header class="header">
        <h2 class="title">
            <a href="/blog/good-js-vol-1" rel="bookmark">Хороший JavaScript. Vol. 1 «Pimp your code»</a>
        </h2>
        
    </header>
    <div class="body"><p>Как известно, JavaScript — язык-ошибка, язык-неочевидное поведение, язык-недоразумение.
Причиной этому являлась необходимость в середине 90 в жесткие сроки получить мощный язык,
позволяющий придать страницам больше возможностей. И получили.
Все проблемы (повсеместные глобальные переменные, область видимости переменных, неочевидные и нелогичные приведения типов)
зашиты в JS глубоко и надолго. Сейчас к нам приближается ES6, который явно, но не достаточно кардинально улучшает ситуацию.</p>
<p>С другой стороны язык очень гибок и никто не запрещает обходить плохие стороны и улучшать язык самому.
Этим я и попробую заняться в серии заметок.
Несгладимое впечатление на меня произвела книга <a href="http://www.ozon.ru/context/detail/id/20217226/" class="nodecor">«<u>JavaScript. Сильные стороны</u>»</a> Дугласа Крокфорда,
рекомендую к прочтению (она совсем небольшая).</p>
<h2><span id="objects">Объекты</span></h2>
<p>Это один из основных механизмов в языке и, надо сказать, удачно реализованный. </p>
<p>Всё (ну, примитивы не совсем объекты, они неизменяемы) в JS — объект. Объекты обладают прототипом, который и сам является объектом. Разные объекты могут иметь один и тот же прототип. 
Каждый раз при изменении прототипа у объекта все другие объекты с этим же прототипом получают его обновленную версию.
Это достигается за счет того, что объекты содержат не копию, а ссылку на прототип. Это способствует экономии памяти и скорости работы.</p>
<p>Помимо прототипа у объекта есть свои, эксклюзивные свойства. Имя свойства может совпадать с именем свойства в прототипе.
Ситуация разрешается просто: JS сначала поищет запрашиваемое свойство в списке личных свойств объекта, а если не найдет, пойдет искать по цепочке прототипов в их свойствах.</p>
<p>Что можно со всем этим делать?</p>
<h2>Расширение функциональности на лету</h2>
<p>Как было сказано, почти все в JS является объектом, в том числе массивы (ага). Мы всегда можем добавить объекту новое свойство.
Давайте попробуем использовать это себе во благо. </p>
<p>Например, имеем список абзацев с текстом на странице. Помимо самих DOM элементов мы хотим хранить рядом с ними какую-то метаинформацию (к примеру, UID абзаца). 
И мы должны уметь удалять и вставлять абзацы в произвольных местах. Работающий пример можно посмотреть <a href="https://jsbin.com/qemaqo/edit?html,js,output">здесь</a>.</p>
<p>Есть следующая страница:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="codehilite"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">&quot;utf-8&quot;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;title&gt;</span>Расширение функциональности на лету<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;div</span> <span class="na">id=</span><span class="s">&quot;content&quot;</span><span class="nt">&gt;&lt;/div&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// ... здесь JS тот, что ниже в статье ...</span>
<span class="p">};</span>
<span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></div>
</td></tr></table>

<p>Объявим массив, где будем хранить наши абзацы, и опишем объект, который будет представлять абзац с текстом и дополнительной информацией.</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span class="kd">var</span> <span class="nx">content</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;content&#39;</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">blocks</span> <span class="o">=</span> <span class="p">[];</span>

<span class="kd">var</span> <span class="nx">block_factory</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">text</span><span class="p">,</span> <span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">);</span>
  <span class="nx">node</span><span class="p">.</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">text</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">node</span><span class="o">:</span> <span class="nx">node</span><span class="p">,</span>
    <span class="nx">meta</span><span class="o">:</span> <span class="nx">meta</span>
  <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>Наша цель — абстрагироваться от работы с DOM и иметь дело только с нашей моделью данных. Чтобы осуществлять вставку и удаление в массиве хорошо подойдет стандартный метод <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">splice</a>.
Но есть проблема: нам всё-таки нужно воздействовать на DOM, чтобы изменения были видны <nobr>визуально :)</nobr> Давайте <em>подправим</em> метод <code>splice</code>, но только для массива <code>blocks</code>:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nx">blocks</span><span class="p">.</span><span class="nx">splice</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">deleteCount</span><span class="p">,</span> <span class="nx">block</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">insert</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Вставляем элемент на заданный индекс в DOM дереве</span>
    <span class="c1">// Текущий и последующие элементы будут сдвинуты вправо</span>
    <span class="nx">content</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">block</span><span class="p">.</span><span class="nx">node</span><span class="p">,</span> <span class="nx">content</span><span class="p">.</span><span class="nx">childNodes</span><span class="p">[</span><span class="nx">start</span><span class="p">]);</span>

    <span class="c1">// Эта конструкция вызывает оригинальный метод splice из прототипа массива</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">splice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">blocks</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">deleteCount</span><span class="p">,</span> <span class="nx">block</span><span class="p">);</span>
  <span class="p">};</span>

  <span class="kd">var</span> <span class="nx">remove</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Вызываем оригинальный метод splice</span>
    <span class="c1">// Он возвращает новый массив с удаленными элементами</span>
    <span class="kd">var</span> <span class="nx">deleted</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">splice</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">blocks</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">deleteCount</span><span class="p">);</span>
    <span class="nx">deleted</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">removed</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Удаляем элемент из DOM</span>
      <span class="nx">content</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">removed</span><span class="p">.</span><span class="nx">node</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="k">return</span> <span class="nx">deleted</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="c1">// Вызываем функцию удаления или вставки в зависимости от аргументов</span>
  <span class="k">return</span> <span class="k">typeof</span> <span class="nx">block</span> <span class="o">===</span> <span class="s1">&#39;undefined&#39;</span> <span class="o">?</span> <span class="nx">remove</span><span class="p">()</span> <span class="o">:</span> <span class="nx">insert</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<p>Для простоты реализации метод перестал поддерживать возможность вставки нескольких элементов разом. Ну и ладно.</p>
<p>Теперь мы можем работать с нашей моделью данных и сразу влиять на DOM:</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="codehilite"><pre><span class="nx">blocks</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">block_factory</span><span class="p">(</span><span class="s1">&#39;Первый абзац&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">uid</span> <span class="o">:</span> <span class="mi">1</span> <span class="p">}));</span>
<span class="nx">blocks</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">block_factory</span><span class="p">(</span><span class="s1">&#39;Второй абзац&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">uid</span> <span class="o">:</span> <span class="mi">2</span> <span class="p">}));</span>
<span class="nx">blocks</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">block_factory</span><span class="p">(</span><span class="s1">&#39;Третий абзац&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">uid</span> <span class="o">:</span> <span class="mi">3</span> <span class="p">}));</span>
<span class="nx">blocks</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">block_factory</span><span class="p">(</span><span class="s1">&#39;Теперь это второй абзац&#39;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">uid</span> <span class="o">:</span> <span class="mi">4</span> <span class="p">}));</span>
<span class="nx">blocks</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Удалим третий по счету абзац (с текстом &#39;Второй абзац&#39;)</span>
</pre></div>
</td></tr></table>

<p>Наш метод <code>splice</code> не затрагивает прототипный метод (помните, выше я писал, что у объектов есть прототип, а есть свои личные методы?), 
поэтому никаких проблем с использование метода у других массивов не будет. 
Эта техника позволяет писать мощный, но в то же время чистый, легко поддерживаемый код.</p>
<p>Подобным образом можно добавлять недостающую функциональность и к прототипам объектов (в том числе стандартным):</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="codehilite"><pre><span class="c1">// Добавляем ко всем объектам типа String метод trim, если его нет</span>
<span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">trim</span> <span class="o">!==</span> <span class="s1">&#39;function&#39;</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">String</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">trim</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^\s+|\s+$/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>В следующей статье мы продолжим работать с прототипами и посмотрим на способы реализации наследования в JavaScript.</p></div>
    <footer class="meta">
        <time datetime="2015-08-20T12:51:00+03:00">20 августа 2015</time>
        <span class="tags">
          <a class="tag nodecor" href="/blog/tags/js">#<u>js</u></a>
          <a class="tag nodecor" href="/blog/tags/series">#<u>series</u></a>
        </span>
    </footer>
</article>
</section>

<footer id="footer">
    <p>© 2015</p>
    <p class="fork-bomb">:(){ :|:& };:</p>
</footer>

</body>
</html>