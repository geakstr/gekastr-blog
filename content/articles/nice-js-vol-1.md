Title: Хороший JavaScript. Vol. 1 «Pimp your code»
Date: 2015-08-20 12:51
Tags: js, series
Slug: nice-js-vol-1

Как известно, JavaScript — язык-ошибка, язык-неочевидное поведение, язык-недоразумение.
Причиной этому являлась необходимость в середине 90 в жесткие сроки получить мощный язык,
позволяющий придать страницам больше возможностей. И получили.
Все проблемы (повсеместные глобальные переменные, область видимости переменных, неочевидные и нелогичные приведения типов)
зашиты в JS глубоко и надолго. Сейчас к нам приближается ES6, который явно, но не достаточно кардинально улучшает ситуацию.

С другой стороны язык очень гибок и никто не запрещает обходить плохие стороны, использовать хорошие и улучшать язык своими силами.
Этим я и займусь в серии заметок.
Несгладимое впечатление на меня произвела книга <a href="http://www.ozon.ru/context/detail/id/20217226/" class="nodecor">«<u>JavaScript. Сильные стороны</u>»</a> Дугласа Крокфорда,
рекомендую к прочтению (она совсем небольшая).

## <span id="objects">Объекты</span>
Это один из основных механизмов в языке и, надо сказать, удачно реализованный. 

Всё (ну, примитивы не совсем объекты, они неизменяемы) в JS — объект. Объекты обладают прототипом, который и сам является объектом со своим набором свойств. 
К прототипам можно относиться как к базовым объектам, задающим начальную функциональность другим объектам. Разные объекты могут иметь один и тот же прототип. 
Каждый раз при изменении прототипа у объекта все другие объекты с этим же прототипом получают его обновленную версию.
Это достигается за счет того, что объекты содержат не копию, а ссылку на прототип. Это способствует экономии памяти и скорости работы.

Помимо прототипа у объекта есть свои, эксклюзивные свойства. Имя свойства может совпадать с именем свойства в прототипе.
Ситуация разрешается просто: JS сначала поищет запрашиваемое свойство в списке личных свойств объекта, а если не найдет, пойдет искать по цепочке прототипов в их свойствах.

Что можно со всем этим делать?

## Расширение функциональности на лету
Как было сказано, почти все в JS является объектом, в том числе массивы (ага). Мы всегда можем добавить объекту новое свойство.
Давайте попробуем использовать это себе во благо. 

Например, имеем список абзацев с текстом на странице. Помимо самих DOM элементов мы хотим хранить рядом с ними какую-то метаинформацию (к примеру, UID абзаца). 
И мы должны уметь удалять и вставлять абзацы в произвольных местах. Работающий пример можно посмотреть [здесь] [js_demo].

Есть следующая страница:

    #!html
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <title>Расширение функциональности на лету</title>
    </head>
    <body>
    <div id="content"></div>
    <script>
    window.onload = function() {
    // ... здесь JS тот, что ниже в статье ...
    };
    </script>
    </body>
    </html>

Объявим массив, где будем хранить наши абзацы, и опишем объект, который будет представлять абзац с текстом и дополнительной информацией.

    #!js
    var content = document.getElementById('content');
    var blocks = [];

    var block_factory = function(text, meta) {
      var node = document.createElement('p');
      node.innerHTML = text;

      return {
        node: node,
        meta: meta
      };
    };

Наша цель — абстрагироваться от работы с DOM и иметь дело только с моделью данных. Чтобы осуществлять вставку и удаление в массиве хорошо подойдет стандартный метод [`splice`] [splice_mozilla_doc].
Но есть проблема: нам всё-таки _нужно_ воздействовать на DOM, чтобы изменения были видны <nobr>визуально :)</nobr> Давайте _подправим_ метод `splice`, но только для массива `blocks`:

    #!js
    blocks.splice = function(start, deleteCount, block) {
      var insert = function() {
        // Вставляем элемент на заданный индекс в DOM дереве
        // Текущий и последующие элементы будут сдвинуты вправо
        content.insertBefore(block.node, content.childNodes[start]);

        // Эта конструкция вызывает оригинальный метод splice из прототипа массива
        return Array.prototype.splice.call(blocks, start, deleteCount, block);
      };

      var remove = function() {
        // Вызываем оригинальный метод splice
        // Он возвращает новый массив с удаленными элементами
        var deleted = Array.prototype.splice.call(blocks, start, deleteCount);
        deleted.forEach(function(removed) {
          // Удаляем элемент из DOM
          content.removeChild(removed.node);
        });
        return deleted;
      };

      // Вызываем функцию удаления или вставки в зависимости от аргументов
      return typeof block === 'undefined' ? remove() : insert();
    };

Для простоты реализации метод перестал поддерживать возможность вставки нескольких элементов разом. Ну и ладно.

Теперь мы можем работать с нашей моделью данных и сразу влиять на DOM:

    #!js
    blocks.splice(0, 0, block_factory('Первый абзац', { uid : 1 }));
    blocks.splice(1, 0, block_factory('Второй абзац', { uid : 2 }));
    blocks.splice(2, 0, block_factory('Третий абзац', { uid : 3 }));
    blocks.splice(1, 0, block_factory('Теперь это второй абзац', { uid : 4 }));
    blocks.splice(2, 1); // Удалим третий по счету абзац (с текстом 'Второй абзац')

Наш метод `splice` не затрагивает прототипный метод (помните, выше я писал, что у объектов есть прототип, а есть свои личные методы?), 
поэтому никаких проблем с использование метода у других массивов не будет. 
Эта техника позволяет писать мощный, но в то же время чистый, легко поддерживаемый код.

Подобным образом можно добавлять недостающую функциональность и к прототипам объектов (в том числе стандартным):

    #!js
    // Добавляем ко всем объектам типа String метод trim, если его нет
    if (typeof String.prototype.trim !== 'function') {
      String.prototype.trim = function () {
        return this.replace(/^\s+|\s+$/g, '');
      }
    }

В следующей статье мы продолжим работать с прототипами и посмотрим на способы реализации наследования в JavaScript.

[splice_mozilla_doc]: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
[js_demo]: https://jsbin.com/qemaqo/edit?html,js,output